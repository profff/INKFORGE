<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>INKFORGE Lite</title>
    <style>
        :root {
            --bg-color: #1a1a2e;
            --surface-color: #16213e;
            --accent-color: #14b8a6;
            --accent-glow: rgba(20, 184, 166, 0.6);
            --warning-color: #f59e0b;
            --warning-glow: rgba(245, 158, 11, 0.6);
            --text-muted: rgba(255, 255, 255, 0.3);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
        }

        body {
            font-family: system-ui, -apple-system, sans-serif;
            background: var(--bg-color);
            color: white;
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .window-frame {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: var(--bg-color);
            overflow: hidden;
        }

        /* Frameless window drag area */
        .drag-area {
            height: 36px;
            background: var(--surface-color);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 14px;
            -webkit-app-region: drag;
        }

        .drag-area * {
            -webkit-app-region: no-drag;
        }

        .logo {
            font-size: 14px;
            font-weight: 700;
            color: var(--accent-color);
            letter-spacing: 1px;
        }

        .window-controls {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        /* LED indicators */
        .leds {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-right: 12px;
        }

        .led {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #333;
            transition: all 0.3s ease;
        }

        .led.active {
            background: var(--accent-color);
            box-shadow: 0 0 8px var(--accent-glow), 0 0 16px var(--accent-glow);
        }

        .led.warning {
            background: var(--warning-color);
            box-shadow: 0 0 8px var(--warning-glow), 0 0 16px var(--warning-glow);
        }

        .led.clickable {
            cursor: pointer;
        }

        .led.clickable:hover {
            transform: scale(1.2);
        }

        /* File menu indicator */
        #fileIndicator {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            color: #aaa;
            background: var(--surface-color) !important;
        }

        /* Window buttons */
        .win-btn {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            border: none;
            cursor: pointer;
            transition: opacity 0.2s;
        }

        .win-btn:hover {
            opacity: 0.8;
        }

        .win-btn.minimize {
            background: #f59e0b;
        }

        .win-btn.maximize {
            background: #22c55e;
        }

        .win-btn.close {
            background: #ef4444;
        }

        /* Main content */
        .main {
            flex: 1;
            display: flex;
            position: relative;
            overflow: hidden;
        }

        /* Canvas container */
        .canvas-container {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            padding: 4px;
        }

        #drawCanvas {
            background: var(--bg-color);
            cursor: crosshair;
        }

        /* Brush size bar */
        .brush-bar {
            position: absolute;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            width: 4px;
            height: 200px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            overflow: hidden;
        }

        .brush-bar-fill {
            position: absolute;
            bottom: 0;
            width: 100%;
            background: var(--accent-color);
            border-radius: 2px;
            transition: height 0.1s ease;
        }

        .brush-bar-indicator {
            position: absolute;
            right: 12px;
            font-size: 11px;
            color: var(--text-muted);
            transform: translateY(-50%);
            pointer-events: none;
        }

        /* Regions overlay */
        .regions-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .region-rect {
            position: absolute;
            border: 1px dashed var(--accent-color);
            background: rgba(20, 184, 166, 0.05);
            border-radius: 2px;
        }

        /* Watermark */
        .watermark {
            position: absolute;
            bottom: 8px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 11px;
            color: var(--text-muted);
            font-family: monospace;
            pointer-events: none;
        }

        /* Cursor styles */
        .cursor-draw {
            cursor: crosshair;
        }

        .cursor-erase {
            cursor: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20"><circle cx="10" cy="10" r="8" fill="none" stroke="%23ff6b6b" stroke-width="2"/></svg>') 10 10, crosshair;
        }

        /* Radial menu component */
        .radial-menu {
            position: absolute;
            width: 36px;
            height: 36px;
            cursor: pointer;
            z-index: 50;
        }

        .radial-menu svg {
            position: absolute;
            width: var(--expanded-size, 160px);
            height: var(--expanded-size, 160px);
            pointer-events: none;
        }

        .radial-menu .cell {
            opacity: 0;
            transform-origin: var(--origin-x, 100%) var(--origin-y, 100%);
            transition: opacity 0.3s ease, transform 0.3s ease, filter 0.15s ease;
            pointer-events: none;
        }

        .radial-menu:hover .cell {
            opacity: 1;
            pointer-events: auto;
        }

        .radial-menu .cell:hover {
            filter: brightness(1.3);
        }

        /* Animation: fan (éventail) - all at once */
        .radial-menu.anim-fan .cell {
            transform: scale(0);
        }
        .radial-menu.anim-fan:hover .cell {
            transform: scale(1);
        }

        /* Animation: push-pull out (intérieur vers extérieur) */
        .radial-menu.anim-push-out .cell {
            transform: scale(0);
        }
        .radial-menu.anim-push-out:hover .cell {
            transform: scale(1);
        }
        .radial-menu.anim-push-out .cell[data-ring="0"] { transition-delay: 0ms; }
        .radial-menu.anim-push-out .cell[data-ring="1"] { transition-delay: 50ms; }
        .radial-menu.anim-push-out .cell[data-ring="2"] { transition-delay: 100ms; }
        .radial-menu.anim-push-out .cell[data-ring="3"] { transition-delay: 150ms; }

        /* Animation: push-pull in (extérieur vers intérieur) */
        .radial-menu.anim-push-in .cell {
            transform: scale(0);
        }
        .radial-menu.anim-push-in:hover .cell {
            transform: scale(1);
        }
        .radial-menu.anim-push-in .cell[data-ring="0"] { transition-delay: 150ms; }
        .radial-menu.anim-push-in .cell[data-ring="1"] { transition-delay: 100ms; }
        .radial-menu.anim-push-in .cell[data-ring="2"] { transition-delay: 50ms; }
        .radial-menu.anim-push-in .cell[data-ring="3"] { transition-delay: 0ms; }

        .radial-menu-indicator {
            position: absolute;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 2px solid rgba(255,255,255,0.5);
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            transition: all 0.3s ease;
            z-index: 10;
        }

        /* Corner positions */
        .radial-menu.bottom-right {
            bottom: 0;
            right: 0;
        }
        .radial-menu.bottom-right svg {
            bottom: 18px;
            right: 18px;
        }
        .radial-menu.bottom-right .radial-menu-indicator {
            bottom: 8px;
            right: 8px;
        }

        .radial-menu.bottom-left {
            bottom: 0;
            left: 0;
        }
        .radial-menu.bottom-left svg {
            bottom: 0;
            left: 0;
        }
        .radial-menu.bottom-left .radial-menu-indicator {
            bottom: 8px;
            left: 8px;
        }

        .radial-menu.top-left {
            top: 8px;
            left: 8px;
        }
        .radial-menu.top-left svg {
            top: 10px;
            left: 10px;
        }
        .radial-menu.top-left .radial-menu-indicator {
            top: 0;
            left: 0;
        }

        /* Hide icons when not hovered */
        .radial-menu .cell-icon {
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        .radial-menu:hover .cell-icon {
            opacity: 1;
        }

        /* Cell with icon/text */
        .radial-menu .cell-icon {
            font-size: 10px;
            fill: white;
            pointer-events: none;
            text-anchor: middle;
            dominant-baseline: middle;
        }
    </style>
</head>
<body>
<div class="window-frame">
    <!-- Drag area for frameless window -->
    <div class="drag-area">
        <span class="logo">INKFORGE LITE</span>

        <div class="window-controls">
            <!-- LED indicators -->
            <div class="leds">
                <div class="led" id="ledConnected" title="Connexion"></div>
                <div class="led" id="ledModified" title="Modifié"></div>
                <div class="led clickable" id="ledZones" title="Afficher zones (clic pour toggle)"></div>
            </div>

            <!-- Window buttons -->
            <button class="win-btn minimize" onclick="minimizeWindow()" title="Réduire"></button>
            <button class="win-btn maximize" onclick="maximizeWindow()" title="Agrandir"></button>
            <button class="win-btn close" onclick="closeWindow()" title="Fermer"></button>
        </div>
    </div>

    <!-- Main canvas area -->
    <div class="main">
        <!-- File menu (radial top-left) -->
        <div class="radial-menu top-left" id="fileMenu" style="--expanded-size: 140px;">
            <div class="radial-menu-indicator" id="fileIndicator" style="background: #555;">☰</div>
        </div>

        <div class="canvas-container" id="canvasContainer">
            <canvas id="drawCanvas"></canvas>

            <!-- Regions overlay -->
            <div class="regions-overlay" id="regionsOverlay"></div>
        </div>

        <!-- Brush size bar -->
        <div class="brush-bar" title="Taille (molette)">
            <div class="brush-bar-fill" id="brushBarFill"></div>
        </div>
        <div class="brush-bar-indicator" id="brushIndicator">3</div>

        <!-- Watermark -->
        <div class="watermark">127.0.0.1:8765</div>

        <!-- Color picker (radial menu) -->
        <div class="radial-menu bottom-right" id="colorPicker" style="--expanded-size: 160px;">
            <div class="radial-menu-indicator" id="colorIndicator"></div>
        </div>
    </div>
</div>

    <script>
        // Constants
        const API_BASE = 'http://127.0.0.1:8765';
        const ERASER_MULTIPLIER = 5;
        const MIN_BRUSH = 1;
        const MAX_BRUSH = 20;

        // DOM elements
        const canvas = document.getElementById('drawCanvas');
        const ctx = canvas.getContext('2d');
        const canvasContainer = document.getElementById('canvasContainer');
        const regionsOverlay = document.getElementById('regionsOverlay');
        const brushBarFill = document.getElementById('brushBarFill');
        const brushIndicator = document.getElementById('brushIndicator');
        const ledConnected = document.getElementById('ledConnected');
        const ledModified = document.getElementById('ledModified');
        const ledZones = document.getElementById('ledZones');

        // State
        let isDrawing = false;
        let isErasing = false;
        let brushSize = 3;
        let brushColor = '#ffffff';
        let lastX = 0;
        let lastY = 0;
        let showZones = false;
        let regions = [];
        let currentRegion = { minX: null, minY: null, maxX: null, maxY: null };
        let history = [];
        let historyIndex = -1;
        let svgVersion = 0;
        let connected = false;
        let modified = false;


        // Initialize
        function init() {
            resizeCanvas();
            updateBrushBar();
            startPolling();
            window.addEventListener('resize', resizeCanvas);

            // LED zones toggle
            ledZones.addEventListener('click', () => {
                showZones = !showZones;
                ledZones.classList.toggle('active', showZones);
                renderRegions();
            });
        }

        function resizeCanvas() {
            // Fixed canvas size
            canvas.width = 800;
            canvas.height = 600;

            // Fill with background color
            ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--bg-color').trim();
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            saveHistory();
        }

        // History management
        function saveHistory() {
            history = history.slice(0, historyIndex + 1);
            history.push(canvas.toDataURL());
            historyIndex = history.length - 1;
            if (history.length > 50) {
                history.shift();
                historyIndex--;
            }
        }

        function undo() {
            if (historyIndex > 0) {
                historyIndex--;
                loadHistoryState();
                // Update modified state
                if (historyIndex === 0) {
                    modified = false;
                    regions = [];
                    ledModified.classList.remove('warning');
                    renderRegions();
                } else if (regions.length > 0) {
                    regions.pop();
                    renderRegions();
                }
            }
        }

        function redo() {
            if (historyIndex < history.length - 1) {
                historyIndex++;
                loadHistoryState();
                modified = true;
                ledModified.classList.add('warning');
            }
        }

        function loadHistoryState() {
            const img = new Image();
            img.onload = () => {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(img, 0, 0);
                syncSnapshot();
            };
            img.src = history[historyIndex];
        }

        // Drawing
        function startDrawing(e) {
            isDrawing = true;
            isErasing = e.button === 2;

            const rect = canvas.getBoundingClientRect();
            lastX = e.clientX - rect.left;
            lastY = e.clientY - rect.top;

            canvas.className = isErasing ? 'cursor-erase' : 'cursor-draw';
            resetCurrentRegion();
            updateCurrentRegion(lastX, lastY);
        }

        function draw(e) {
            if (!isDrawing) return;

            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            ctx.beginPath();
            ctx.moveTo(lastX, lastY);
            ctx.lineTo(x, y);

            if (isErasing) {
                ctx.strokeStyle = getComputedStyle(document.body).getPropertyValue('--bg-color').trim();
                ctx.lineWidth = brushSize * ERASER_MULTIPLIER;
            } else {
                ctx.strokeStyle = brushColor;
                ctx.lineWidth = brushSize;
            }

            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.stroke();

            updateCurrentRegion(x, y);
            lastX = x;
            lastY = y;
        }

        function stopDrawing() {
            if (!isDrawing) return;
            isDrawing = false;

            if (currentRegion.minX !== null) {
                const region = {
                    x: Math.round(currentRegion.minX),
                    y: Math.round(currentRegion.minY),
                    w: Math.round(currentRegion.maxX - currentRegion.minX),
                    h: Math.round(currentRegion.maxY - currentRegion.minY)
                };
                regions.push(region);
                modified = true;
                ledModified.classList.add('warning');

                // Sync with backend
                syncRegion(region);
                saveHistory();
                syncSnapshot();
                renderRegions();
            }

            resetCurrentRegion();
            canvas.className = 'cursor-draw';
        }

        function resetCurrentRegion() {
            currentRegion = { minX: null, minY: null, maxX: null, maxY: null };
        }

        function updateCurrentRegion(x, y) {
            const margin = brushSize * (isErasing ? ERASER_MULTIPLIER : 1) + 5;
            if (currentRegion.minX === null) {
                currentRegion.minX = x - margin;
                currentRegion.minY = y - margin;
                currentRegion.maxX = x + margin;
                currentRegion.maxY = y + margin;
            } else {
                currentRegion.minX = Math.max(0, Math.min(currentRegion.minX, x - margin));
                currentRegion.minY = Math.max(0, Math.min(currentRegion.minY, y - margin));
                currentRegion.maxX = Math.min(canvas.width, Math.max(currentRegion.maxX, x + margin));
                currentRegion.maxY = Math.min(canvas.height, Math.max(currentRegion.maxY, y + margin));
            }
        }

        // Brush size
        function adjustBrushSize(delta) {
            brushSize = Math.max(MIN_BRUSH, Math.min(MAX_BRUSH, brushSize + delta));
            updateBrushBar();
        }

        function updateBrushBar() {
            const percent = ((brushSize - MIN_BRUSH) / (MAX_BRUSH - MIN_BRUSH)) * 100;
            brushBarFill.style.height = percent + '%';
            brushIndicator.textContent = brushSize;
            brushIndicator.style.bottom = `calc(50% - 100px + ${percent * 2}px)`;
        }

        // Regions rendering
        function renderRegions() {
            regionsOverlay.innerHTML = '';
            if (!showZones) return;

            const rect = canvas.getBoundingClientRect();
            const containerRect = canvasContainer.getBoundingClientRect();
            const offsetX = rect.left - containerRect.left;
            const offsetY = rect.top - containerRect.top;

            regions.forEach(r => {
                const div = document.createElement('div');
                div.className = 'region-rect';
                div.style.left = (offsetX + r.x) + 'px';
                div.style.top = (offsetY + r.y) + 'px';
                div.style.width = r.w + 'px';
                div.style.height = r.h + 'px';
                regionsOverlay.appendChild(div);
            });
        }

        // API communication
        async function syncSnapshot() {
            const currentB64 = canvas.toDataURL('image/png').split(',')[1];
            try {
                await fetch(`${API_BASE}/snapshot`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ current: currentB64 })
                });
            } catch (e) {
                console.error('Failed to sync snapshot:', e);
            }
        }

        async function syncRegion(region) {
            try {
                await fetch(`${API_BASE}/region`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(region)
                });
            } catch (e) {
                console.error('Failed to sync region:', e);
            }
        }

        async function clearCanvas() {
            ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--bg-color').trim();
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            regions = [];
            modified = false;
            ledModified.classList.remove('warning');
            renderRegions();
            saveHistory();

            try {
                await fetch(`${API_BASE}/clear`, { method: 'POST' });
            } catch (e) {
                console.error('Failed to clear backend:', e);
            }
        }

        // Polling for SVG updates
        function startPolling() {
            setInterval(async () => {
                try {
                    const res = await fetch(`${API_BASE}/svg`);
                    const data = await res.json();

                    if (data.svg && data.version > svgVersion) {
                        svgVersion = data.version;
                        autoInjectSvg(data.svg);
                    }

                    connected = true;
                    ledConnected.classList.add('active');
                } catch (e) {
                    connected = false;
                    ledConnected.classList.remove('active');
                }
            }, 500);
        }

        // Auto-inject SVG
        function autoInjectSvg(svg) {
            const svgBlob = new Blob([svg], { type: 'image/svg+xml;charset=utf-8' });
            const url = URL.createObjectURL(svgBlob);

            const img = new Image();
            img.onload = () => {
                // Clear canvas
                ctx.fillStyle = getComputedStyle(document.body).getPropertyValue('--bg-color').trim();
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Scale and center
                const scale = Math.min(
                    canvas.width / img.width,
                    canvas.height / img.height
                ) * 0.9;

                const x = (canvas.width - img.width * scale) / 2;
                const y = (canvas.height - img.height * scale) / 2;

                ctx.drawImage(img, x, y, img.width * scale, img.height * scale);

                URL.revokeObjectURL(url);
                saveHistory();
                syncSnapshot();

                // Reset state
                regions = [];
                modified = false;
                ledModified.classList.remove('warning');
                renderRegions();
            };
            img.src = url;
        }

        // Window controls
        function minimizeWindow() {
            if (window.pywebview) {
                window.pywebview.api.minimize();
            }
        }

        function maximizeWindow() {
            if (window.pywebview) {
                window.pywebview.api.maximize();
            }
        }

        function closeWindow() {
            if (window.pywebview) {
                window.pywebview.api.close();
            } else {
                window.close();
            }
        }

        // Save function
        async function saveAs() {
            const dataUrl = canvas.toDataURL('image/png');
            if (window.pywebview) {
                window.pywebview.api.save_file(dataUrl.split(',')[1]);
            } else {
                // Fallback: download link
                const a = document.createElement('a');
                a.href = dataUrl;
                a.download = 'inkforge-sketch.png';
                a.click();
            }
        }

        // Window drag
        let isDragging = false;
        let dragStartX = 0;
        let dragStartY = 0;

        const dragArea = document.querySelector('.drag-area');

        dragArea.addEventListener('mousedown', e => {
            // Only drag on the drag area itself, not on buttons/LEDs
            if (e.target === dragArea || e.target.classList.contains('logo')) {
                isDragging = true;
                dragStartX = e.screenX;
                dragStartY = e.screenY;
                e.preventDefault();
            }
        });

        document.addEventListener('mousemove', e => {
            if (isDragging && window.pywebview) {
                const dx = e.screenX - dragStartX;
                const dy = e.screenY - dragStartY;
                dragStartX = e.screenX;
                dragStartY = e.screenY;
                window.pywebview.api.move_window(dx, dy);
            }
        });

        document.addEventListener('mouseup', () => {
            isDragging = false;
        });

        // Event listeners
        canvas.addEventListener('mousedown', startDrawing);
        canvas.addEventListener('mousemove', draw);
        canvas.addEventListener('mouseup', stopDrawing);
        canvas.addEventListener('mouseleave', stopDrawing);
        canvas.addEventListener('contextmenu', e => e.preventDefault());

        // Mouse wheel for brush size
        canvas.addEventListener('wheel', e => {
            e.preventDefault();
            adjustBrushSize(e.deltaY > 0 ? -1 : 1);
        });

        // Keyboard shortcuts
        document.addEventListener('keydown', e => {
            if (e.ctrlKey && e.key === 'z') {
                e.preventDefault();
                undo();
            } else if (e.ctrlKey && e.key === 'y') {
                e.preventDefault();
                redo();
            } else if (e.key === 'Delete' || e.key === 'Escape') {
                clearCanvas();
            }
        });

        /**
         * RadialMenu - Composant de menu radial en quart de cercle
         * @param {Object} config
         * @param {HTMLElement} config.container - Element conteneur
         * @param {string} config.corner - 'bottom-right', 'bottom-left', 'top-right', 'top-left'
         * @param {number} config.size - Taille déployée en px
         * @param {number} config.innerRadius - Rayon minimum (trou central) en % (0-100)
         * @param {string} config.animation - 'fan', 'push-out', 'push-in'
         * @param {Array} config.rings - Tableau d'anneaux, chaque anneau = { divisions: [...] }
         *   division = { color?, icon?, label?, action: function }
         */
        class RadialMenu {
            constructor(config) {
                this.container = config.container;
                this.corner = config.corner || 'bottom-right';
                this.size = config.size || 160;
                this.innerRadius = config.innerRadius || 15; // % du rayon total pour le trou central
                this.animation = config.animation || 'fan';
                this.rings = config.rings || [];

                this.container.classList.add(`anim-${this.animation}`);
                this.container.style.setProperty('--expanded-size', this.size + 'px');

                // Set transform origin based on corner
                const origins = {
                    'bottom-right': { x: '100%', y: '100%' },
                    'bottom-left': { x: '0%', y: '100%' },
                    'top-right': { x: '100%', y: '0%' },
                    'top-left': { x: '0%', y: '0%' }
                };
                const origin = origins[this.corner];
                this.container.style.setProperty('--origin-x', origin.x);
                this.container.style.setProperty('--origin-y', origin.y);

                this.render();
            }

            pointOnCircle(cx, cy, radius, angleDeg) {
                const angleRad = (angleDeg * Math.PI) / 180;
                return {
                    x: cx + radius * Math.cos(angleRad),
                    y: cy + radius * Math.sin(angleRad)
                };
            }

            createCellPath(cx, cy, innerR, outerR, startAngle, endAngle) {
                const p1 = this.pointOnCircle(cx, cy, innerR, startAngle);
                const p2 = this.pointOnCircle(cx, cy, outerR, startAngle);
                const p3 = this.pointOnCircle(cx, cy, outerR, endAngle);
                const p4 = this.pointOnCircle(cx, cy, innerR, endAngle);
                const largeArc = Math.abs(endAngle - startAngle) > 180 ? 1 : 0;

                return `M ${p1.x},${p1.y} L ${p2.x},${p2.y} A ${outerR},${outerR} 0 ${largeArc},1 ${p3.x},${p3.y} L ${p4.x},${p4.y} A ${innerR},${innerR} 0 ${largeArc},0 ${p1.x},${p1.y} Z`;
            }

            getAngleRange() {
                switch (this.corner) {
                    case 'bottom-right': return { start: 180, end: 270, cx: 100, cy: 100 };
                    case 'bottom-left': return { start: 270, end: 360, cx: 0, cy: 100 };
                    case 'top-right': return { start: 90, end: 180, cx: 100, cy: 0 };
                    case 'top-left': return { start: 0, end: 90, cx: 0, cy: 0 };
                    default: return { start: 180, end: 270, cx: 100, cy: 100 };
                }
            }

            setAnimation(anim) {
                this.container.classList.remove(`anim-${this.animation}`);
                this.animation = anim;
                this.container.classList.add(`anim-${this.animation}`);
            }

            render() {
                const { start, end, cx, cy } = this.getAngleRange();
                const totalAngle = end - start;
                const numRings = this.rings.length;
                const availableRadius = 100 - this.innerRadius;

                const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                svg.setAttribute('viewBox', '0 0 100 100');

                // Dalle fantôme invisible pour maintenir le hover
                const ghostCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                ghostCircle.setAttribute('cx', cx);
                ghostCircle.setAttribute('cy', cy);
                ghostCircle.setAttribute('r', this.innerRadius + 5);
                ghostCircle.setAttribute('fill', 'transparent');
                ghostCircle.setAttribute('class', 'cell');
                svg.appendChild(ghostCircle);

                this.rings.forEach((ring, ringIndex) => {
                    const innerR = this.innerRadius + (ringIndex / numRings) * availableRadius;
                    const outerR = this.innerRadius + ((ringIndex + 1) / numRings) * availableRadius;
                    const divisions = ring.divisions;
                    const anglePerDiv = totalAngle / divisions.length;

                    divisions.forEach((div, divIndex) => {
                        const startAngle = start + divIndex * anglePerDiv;
                        const endAngle = start + (divIndex + 1) * anglePerDiv;

                        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                        path.setAttribute('d', this.createCellPath(cx, cy, innerR, outerR, startAngle, endAngle));
                        path.setAttribute('fill', div.color || '#444');
                        path.setAttribute('class', 'cell');
                        path.setAttribute('data-ring', ringIndex);
                        path.style.cursor = 'pointer';

                        if (div.action) {
                            path.addEventListener('click', (e) => {
                                e.stopPropagation();
                                div.action(div, e);
                            });
                        }

                        svg.appendChild(path);

                        // Add icon if specified (SVG path or text)
                        if (div.icon || div.svgPath) {
                            const midAngle = (startAngle + endAngle) / 2;
                            const midR = (innerR + outerR) / 2;
                            const pos = this.pointOnCircle(cx, cy, midR, midAngle);

                            if (div.svgPath) {
                                // SVG path icon
                                const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                                const iconSize = 8;
                                g.setAttribute('transform', `translate(${pos.x - iconSize/2}, ${pos.y - iconSize/2}) scale(${iconSize/24})`);
                                g.setAttribute('class', 'cell-icon');
                                const pathEl = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                                pathEl.setAttribute('d', div.svgPath);
                                pathEl.setAttribute('fill', 'none');
                                pathEl.setAttribute('stroke', 'white');
                                pathEl.setAttribute('stroke-width', '2');
                                pathEl.setAttribute('stroke-linecap', 'round');
                                pathEl.setAttribute('stroke-linejoin', 'round');
                                g.appendChild(pathEl);
                                svg.appendChild(g);
                            } else {
                                // Text icon
                                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                                text.setAttribute('x', pos.x);
                                text.setAttribute('y', pos.y);
                                text.setAttribute('class', 'cell-icon');
                                text.textContent = div.icon;
                                svg.appendChild(text);
                            }
                        }
                    });
                });

                this.container.insertBefore(svg, this.container.firstChild);
            }
        }

        // Helper: génère une palette de couleurs avec dégradés
        function generateColorPalette(baseHues, rings = 4) {
            const palette = [];
            for (let r = 0; r < rings; r++) {
                const lightness = 25 + (r * 15); // 25%, 40%, 55%, 70%
                const saturation = 100 - (r * 10); // 100%, 90%, 80%, 70%
                palette.push({
                    divisions: baseHues.map(hue => ({
                        color: `hsl(${hue}, ${saturation}%, ${lightness}%)`,
                        hue, saturation, lightness
                    }))
                });
            }
            return palette;
        }

        // Color picker avec RadialMenu - 4 étages avec dégradés
        const colorIndicator = document.getElementById('colorIndicator');

        function updateColorIndicator() {
            colorIndicator.style.background = brushColor;
        }

        // Teintes de base (8 couleurs)
        const baseHues = [0, 30, 60, 120, 180, 210, 270, 320];

        // Génère la palette avec 4 anneaux
        const colorRings = generateColorPalette(baseHues, 4);

        // Ajoute les actions à chaque cellule
        colorRings.forEach(ring => {
            ring.divisions.forEach(div => {
                div.action = (d) => {
                    brushColor = d.color;
                    updateColorIndicator();
                };
            });
        });

        const colorPicker = new RadialMenu({
            container: document.getElementById('colorPicker'),
            corner: 'bottom-right',
            size: 180,
            animation: 'push-out', // 'fan', 'push-out', 'push-in'
            rings: colorRings
        });

        updateColorIndicator();

        // Lucide-style SVG paths (viewBox 24x24)
        const ICONS = {
            save: 'M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2zM17 21v-8H7v8M7 3v5h8',
            trash: 'M18 6L6 18M6 6l12 12',
            clipboard: 'M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2M9 2h6v4H9z'
        };

        // File menu en top-left
        const fileMenu = new RadialMenu({
            container: document.getElementById('fileMenu'),
            corner: 'top-left',
            size: 140,
            animation: 'push-out',
            rings: [{
                divisions: [
                    { color: '#2a4a5e', svgPath: ICONS.save, action: () => saveAs() },
                    { color: '#2a4a5e', svgPath: ICONS.trash, action: () => clearCanvas() },
                    { color: '#2a4a5e', svgPath: ICONS.clipboard, action: () => navigator.clipboard?.writeText(canvas.toDataURL()) },
                ]
            }]
        });

        // Initialize on load
        window.addEventListener('load', init);
    </script>
</body>
</html>
